# Uso de Storage en Supabase

Primero, vamos a implementar la funcionalidad para subir archivos sin tener en 
cuenta los permisos del usuario, es decir, serÃ¡n pÃºblicos.

DespuÃ©s, vamos a incluir la funcionalidad de iniciar sesiÃ³n para que un usuario
solo pueda interactuar con sus propios archivos (funcionamiento habitual en una
app como Google Drive, Dropbox, etc.).

Finalmente, vamos a incluir una funcionalidad simple de compartir archivos para
que un usuario pueda ver un archivo compartido por nosotros.

---

## Pasos Previos

### ReubicaciÃ³n de archivos: Screaming Architecture

Actualmente, no todos los archivos no estÃ¡n ubicados en el proyecto segÃºn su 
funcionalidad. Esto es recomendable para proyectos que involucren escalabilidad y
equipos de trabajo colaborando.

Usaremos la metodologÃ­a denominada "Screaming Architecture" para reubicar los archivos
del proyecto. Esta metodologÃ­a se puede resumir de la siguiente forma:

> Se colocan los archivos en carpetas segÃºn funcionalidad y acciÃ³n a realizar, 
los archivos se nombran de forma idÃ©ntica en estas carpetas.

Es decir, si necesito dos controladores para dos features de "alquiler de coches" 
y "subida de archivos" crearÃ­a las carpetas `car-rental` y `uploads` y colocarÃ­a
el controlador respectivo en cada subcarpeta. 

MÃ¡s informaciÃ³n sobre screaming architecture en:

- [ðŸ‡ªðŸ‡¸ Post sobre Screaming Architecture](https://withoutdebugger.com/2023/11/25/screaming-architecture/)
- [ðŸ‡¬ðŸ‡§ Screaming aplicado a React](https://dev.to/profydev/screaming-architecture-evolution-of-a-react-folder-structure-4g25)
- [ðŸ‡¬ðŸ‡§ ExplicaciÃ³n sobre Screaming](https://www.milanjovanovic.tech/blog/screaming-architecture)

#### Archivos de Practica 01

Primer nivel de carpetas en `tasks-app`:

```bash
  $ tree -L 1 tasks-app
  
  tasks-app
  â”œâ”€â”€ README.md
  â”œâ”€â”€ app
  â”œâ”€â”€ app.json
  â”œâ”€â”€ assets
  â”œâ”€â”€ components
  â”œâ”€â”€ constants
  â”œâ”€â”€ crud
  â”œâ”€â”€ env.local.sample
  â”œâ”€â”€ expo-env.d.ts
  â”œâ”€â”€ hooks
  â””â”€â”€ node_modules
```

Segundo nivel:

```bash
  $ tree -L 2 tasks-app
  tasks-app
  â”œâ”€â”€ README.md
  â”œâ”€â”€ app
  â”‚   â”œâ”€â”€ (tabs)
  â”‚   â”œâ”€â”€ +not-found.tsx
  â”‚   â”œâ”€â”€ _layout.tsx
  â”‚   â””â”€â”€ supabaseClient.ts
  â”œâ”€â”€ app.json
  â”œâ”€â”€ assets
  â”‚   â”œâ”€â”€ fonts
  â”‚   â””â”€â”€ images
  â”œâ”€â”€ components
  â”‚   â”œâ”€â”€ Collapsible.tsx
  â”‚   â”œâ”€â”€ ExternalLink.tsx
  â”‚   â”œâ”€â”€ HapticTab.tsx
  â”‚   â”œâ”€â”€ HelloWave.tsx
  â”‚   â”œâ”€â”€ ParallaxScrollView.tsx
  â”‚   â”œâ”€â”€ ThemedText.tsx
  â”‚   â”œâ”€â”€ ThemedView.tsx
  â”‚   â”œâ”€â”€ __tests__
  â”‚   â””â”€â”€ ui
  â”œâ”€â”€ constants
  â”‚   â””â”€â”€ Colors.ts
  â”œâ”€â”€ crud
  â”‚   â”œâ”€â”€ TaskForm.tsx
  â”‚   â””â”€â”€ TaskList.tsx
  â”œâ”€â”€ env.local.sample
  â”œâ”€â”€ expo-env.d.ts
  â”œâ”€â”€ hooks
  â”‚   â”œâ”€â”€ useColorScheme.ts
  â”‚   â”œâ”€â”€ useColorScheme.web.ts
  â”‚   â””â”€â”€ useThemeColor.ts
  â””â”€â”€ node_modules
      â”œâ”€â”€ @0no-co
      â”œâ”€â”€ @ampproject
      â”œâ”€â”€ @babel
      â”œâ”€â”€ ...
      â”œâ”€â”€ chownr
      â”œâ”€â”€ chrome-launcher
      â”œâ”€â”€ chrome-trace-event
```

Aplicando Screaming Architecture:

```bash
  tasks-app/
  â”œâ”€â”€ app/                              <- se mantiene igual
  â”œâ”€â”€ assets/                           <- se mantiene igual
  â”œâ”€â”€ components/
  â”‚   â”œâ”€â”€ ui/                           <- se mantiene igual
  â”‚   â”œâ”€â”€ Collapsible.tsx               <- se mantiene igual
  â”‚   â”œâ”€â”€ ExternalLink.tsx              <- se mantiene igual
  â”‚   â”œâ”€â”€ HapticTab.tsx                 <- se mantiene igual
  â”‚   â”œâ”€â”€ HelloWave.tsx                 <- se mantiene igual
  â”‚   â”œâ”€â”€ ParallaxScrollView.tsx        <- se mantiene igual
  â”‚   â”œâ”€â”€ ThemedText.tsx                <- se mantiene igual
  â”‚   â”œâ”€â”€ ThemedView.tsx                <- se mantiene igual
  â”‚   â””â”€â”€ __tests__/                    <- se mantiene igual
  â”œâ”€â”€ constants/
  â”‚   â””â”€â”€ Colors.ts                     <- se mantiene igual
  â”œâ”€â”€ core/
  â”‚   â”œâ”€â”€ supabase/
  â”‚   â”‚   â””â”€â”€ supabaseClient.ts         <- lo movemos desde `app/supabaseClient.ts`
  â”‚   â”œâ”€â”€ hooks/
  â”‚   â”‚   â”œâ”€â”€ useColorScheme.ts         <- lo movemos desde `hooks/`
  â”‚   â”‚   â”œâ”€â”€ useColorScheme.web.ts     <- lo movemos desde `hooks/`
  â”‚   â”‚   â”œâ”€â”€ useThemeColor.ts          <- lo movemos desde `hooks/`
  â”œâ”€â”€ features/
  â”‚   â”œâ”€â”€ tasks/
  â”‚   â”‚   â”œâ”€â”€ components/
  â”‚   â”‚   â”‚   â”œâ”€â”€ TaskForm.tsx          <- lo movemos desde `crud/TaskForm.tsx`
  â”‚   â”‚   â”‚   â”œâ”€â”€ TaskList.tsx          <- lo movemos desde `crud/TaskList.tsx`
  â”‚   â”‚   â”œâ”€â”€ services/
  â”‚   â”‚   â”‚   â””â”€â”€ taskService.ts        <- nuevo archivo para la lÃ³gica de tareas
  â”‚   â”‚   â”œâ”€â”€ models/
  â”‚   â”‚   â”‚   â””â”€â”€ Task.ts               <- nuevo archivo para definir el modelo `Task`
  â”‚   â”‚   â””â”€â”€ screens/
  â”‚   â”‚       â””â”€â”€ TaskScreen.tsx        <- combina TaskForm y TaskList => componente completo para los Tasks
  â”‚   â”‚       ...
  â”œâ”€â”€ env.local.sample                  <- se mantiene igual
  â”œâ”€â”€ expo-env.d.ts                     <- se mantiene igual
  â””â”€â”€ node_modules/                     <- se mantiene igual
```

Mientras se realiza la reubicaciÃ³n, hay que confgurar alias en `tsconfig.json`
para importar los archivos necesarios y se recomienda renombrar algunos archivos
para no ser redundantes, por ejemplo:

![alt text](image.png)

En este caso `supabase/supabaseClient.ts` es repetitivo, lo renombramos como
`supabase/client.ts` ya que no tendrÃ­a sentido un cliente (arhivo con clase 
singleton para conectar al servicio) de otro proveedor en esta carpeta. En algunos 
casos se puede preferir `index.*` como el punto de entrada de la carpeta 
(`index.ts` harÃ­a el exporte del client y habrÃ­a un `client.ts` con la clase) pero es 
mÃ¡s Ãºtil cuando se usan muchos archivos. Screaming es muy adaptable en este sentido.

![alt text](image-1.png)

**Nota:** a veces el servidor de Typescript no detecta el renombre del archivo
inmediatamente, si esta lÃ­nea tiene el alias y la importaciÃ³n bien pero sale error:

```typescript
  import supabase from '@core/supabase/client';
```

`tsconfig.json`:

```typescript
...
  // dentro de "paths":
  "@core/*": [
        "./core/*"
      ]
...
```

Soluciones habituales de problemas con importacines en `.ts` pueden ser:

- Reiniciar el servidor de Typescript: <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd> -> reiniciar servidor Typescript
- Borrar hasta la Ãºltima `/` incluida (en `'@core/supabase/client'`) y usar el autocompletado para que se recargue la referencia de la imporaciÃ³n 
- Cerrar y abris VS Code

La importaciÃ³n es correcta si al hacer <Ctrl> + click en `'@core/supabase/client'` 
se abre el archivo.

**Nota:** vamos a evitar referencias relativas como:

```typescript
  import TaskForm from './TaskForm';
```

cambiado a:

```typescript
  import TaskForm from '@tasks/components/TaskForm';
```

Esta importaciÃ³n es mÃ¡s verbosa y tal vez no se vea su utilidad inmediatamente.
Sin embargo, imaginemos que tenemos formularios de alquiler de coches y de tareas
y que, ademas, ambos se llaman `form.jsx`, Â¿no serÃ­a mejor importarlos asÃ­?

```typescript
  import TaskForm from '@tasks/components/form';
  import TaskForm from '@carRental/components/form';
```

O incluso hacer una carpeta forms y definir mÃ¡s el formulario: rentCarForm, rentCar, 
create, createForm, etc. NÃ³tese que en este caso incluir `Form` en el nombre de 
archivo serÃ­a opcional. No vamos a especificar tanto por ahora pero se puede apreciar
las opciones para escalar el proyecto con esta arquitectura.

### Limpieza del CÃ³digo: refactor

Si buscamos el siguiente snippet aparece mÃ¡s de una vez en el cÃ³digo de practica 01:

```typescript
  interface Task {
    id: number;
    title: string;
    description: string;
    completed: boolean;
  }
```

Esta interfaz sirve para declarar un tipo que se debe usar en alguna parte del proyecto.
No tiene sentido que aparezca en mÃ¡s de un lugar el 99% de las veces ya que mantener 
las interfaces al dÃ­a serÃ­a complicado. Vamos a recolocar esta interfaz en `tasks/models`
ya que sirve tambiÃ©n para modelizar los datos de una tarea y pasamos a importar desde
`Task.ts`.

![alt text](image-2.png)

Usamos la lupa de VS Code para buscar en todos los archivos dentro de `practica02`:

- Borramos la interfaz
- Actualizamos (si es necesario) el `tsconfig.json` con un alias
- Importamos desde `Task.ts` en: `index.tsx`, `TaskForm.tsx` y `TaskList.jsx`

**Nota:** es posible hacer este refactor desde la lupa usando `Reemplazar`. 
Especialmente Ãºtil cuando son muchos archivos para editar.

```typescript
// Define el tipo de las tareas -> importamos desde Task.ts
import Task from '@tasks/models/Task';
```

Resolvemos estos problemas de importaciÃ³n en `index.tsx`:

![alt text](image-3.png)

SegÃºn como hayas creados los alias y colocado las importaciones podrÃ­as encontrar
otros problemas similares en diversos archivos. El resultado puede ser similar a:

![alt text](image-4.png)

Llegados a este punto podemos probar con `npm run web` si el proyeto refactorizado
funciona como debe:

![alt text](image-5.png)

Es posible que veas errores de importaciones como este. Se debe a como se accede 
a la carpeta `hooks`, se puede resolver creando otro alias o editando la imporaciÃ³n 
desde la lupa:

![alt text](image-6.png)

Si quieres reemplazar todo tendrÃ¡s que confirmar:

![alt text](image-7.png)

Este otro error de importaciÃ³n tambiÃ©n es debido al cambio de carpetas:

![alt text](image-8.png)

Usamos la lupa y creamos el alias `components` (opcional):

![alt text](image-9.png)

**ObservaciÃ³n:** en la primera caja no hace falta colocar `'` y `'` ya que borrarÃ­a 
las comillas.

**Nota:** Es posible hacer <kbd>Ctrl</kbd> + <kbd>Z</kbd> para deshacer una ediciÃ³n 
mÃºltiple con esta herramienta. 

---

Siguiente paso: [Storage](./02.storage.md)